---
title: "Visium Spatial Transcriptomics Data Analysis - Mouse Intestine"
output:
  html_document:
    df_print: paged
editor_options: 
  markdown: 
    wrap: sentence
---

First we need to set up the environment and load the packages we will use for this workshop.

*library(Seurat)*: Loads the Seurat package, which is a comprehensive toolkit for single-cell RNA sequencing and spatial transcriptomics data analysis.
It provides a wide range of functions for data preprocessing, normalization, clustering, dimensionality reduction, and visualization.
Explore documentation here: <https://satijalab.org/seurat/>

*library(ggplot2)*: Loads the ggplot2 package, a powerful and flexible system for creating static visualizations in R.
Explore documentation here: <https://ggplot2.tidyverse.org/>

*library(DropletUtils)*: Loads the DropletUtils package, which provides tools for analyzing droplet-based single-cell RNA sequencing data.
It includes functions for processing raw sequencing data, detecting empty droplets, and extracting counts and also has useful functions for spatial transcriptomics data.
Explore documentation here: <https://bioconductor.org/packages/release/bioc/html/DropletUtils.html>

*library(SpotClean)*: Loads the SpotClean package, designed to improve the resolution and quality of spatial transcriptomics data.
It offers algorithms for removing background noise and refining spot-level data, enhancing the accuracy of spatial gene expression measurements.
Explore documentation here: <https://www.bioconductor.org/packages/release/bioc/html/SpotClean.html>

*library(SpatialExperiment)*: Loads the SpatialExperiment package, which provides data structures and methods for managing spatially resolved transcriptomics data.
It builds on Bioconductor's SingleCellExperiment framework to support spatial assays.
Explore documentation here: <https://www.bioconductor.org/packages/release/bioc/html/SpatialExperiment.html>

*library(scCustomize)*: Loads the scCustomize package, which provides custom functions and themes to enhance the visualization and analysis capabilities of single-cell and spatial transcriptomics data, often in conjunction with Seurat.
Explore documentation here: <https://samuel-marsh.github.io/scCustomize/>

*library(clustree)*: Loads the clustree package, which is used for visualizing cluster trees.
It helps analyze and compare clustering results across different resolutions or parameter settings, facilitating the exploration of hierarchical relationships between clusters.
Explore documentation here: <https://lazappi.github.io/clustree/>

*library(CARD)*: Loads the CARD (Cell-type Assignment and Reference-based Deconvolution) package, which is used for cell-type deconvolution in spatial transcriptomics.
It assigns cell types to spatial spots using reference single-cell RNA-seq data.
Explore documentation here: <https://yma-lab.github.io/CARD/>

*library(MuSiC)*: Loads the MuSiC (Multi-Subject Single-Cell Deconvolution) package, which is a tool for deconvolving bulk RNA-seq data into cell-type proportions using single-cell reference data.
It is designed to work across multiple subjects or conditions and required by CARD package.
Explore documentation here: <https://xuranw.github.io/MuSiC/articles/MuSiC.html>

```{r Setting up the environment}
library(Seurat)
library(ggplot2)
library(DropletUtils)
library(SpotClean)
library(SpatialExperiment)
library(scCustomize)
library(clustree)
library(CARD)
library(MuSiC)
library(corrplot)
```

##LOADING DATA

Seurat provides handy wrapper functions for reading in common spatial transcriptomics platform outputs.
These functions are typically called *Load[platform]* - e.g.
*LoadXenium*, *LoadNanostring*.
Explore the Seurat package documentation to find more.

Function: *Load10X_Spatial* is a function from the Seurat package designed to read spatial transcriptomics data generated by 10X Genomics Visium technology.
It loads both gene expression data and spatial coordinates into a Seurat object.

*data.dir* Argument: The first argument specifies the directory path where the 10X Genomics Visium output files are located.
This path points to the output directory containing necessary data files, including spatial coordinates and expression matrices.

*filename* Argument: Specifies the file name of the HDF5 (Hierarchical Data Format version 5) file containing the gene expression matrix.
The raw_feature_bc_matrix.h5 file includes raw gene expression counts for each barcode corresponding to a spot on the tissue slide.

*slice* Argument: This argument assigns a name or identifier to the tissue section being loaded.
Here, we use "mouse_intestine_section1" but this could be something more informative, or an internal ID, for example associated with additional sample meta data.

*filter.matrix* Argument: A logical argument that determines whether to filter the matrix based on barcodes associated with tissue-covered spots.
Setting it to FALSE means that all barcodes, including those not associated with tissue, will be included in the Seurat object.

```{r Loading Data}
visium_dir <- "/project/shared/spatial_data_camp/datasets/DATASET1/VISIUM_V1_MOUSE_INTESTINE/spaceranger/SRR14083626_HEALTHY_DAY0/outs"

seurat <- Load10X_Spatial(data.dir=visium_dir, 
                         filename = "raw_feature_bc_matrix.h5", 
                         slice="mouse_intestine_section1",
                         filter.matrix = FALSE)
```

##INSPECTING LOADED DATA

You can inspect the Seurat object that has been created, which will print a summary of the data.
*"Samples"* in this case refer to the number of visium spots *"Features"* refer to the number of genes measured

```{r Inspecting Seurat Object}
seurat
```

##EXPLORING SEURAT OBJECT

The below code shows how to access various components of a Seurat object.
For full documentation, see: <https://satijalab.github.io/seurat-object/>

*Cells(seurat)*: This function retrieves all the barcodes that identify individual cells or spots in the Seurat object.
Barcodes are unique identifiers for each spot on the Visium slide, which helps to distinguish between different locations within the tissue section.

*Features(seurat)*: This command lists all features present in the Seurat object.
Features typically include genes whose expression levels are measured across different spots in the spatial transcriptomics dataset, but could be other measures or downstream values - e.g. cell type scores.

*Assays(seurat)*: This command provides a list of all assays present in the Seurat object.
Assays are different data modalities or subsets, such as RNA expression, spatial data, signature scores etc.

*Features(seurat[["Spatial"]])*: As in *Features(seurat)*, but will access features specifically from the 'Spatial' assay only.

*Idents(seurat)*: This function retrieves the current active identity or classification of cells/spots in the Seurat object.
These identities are often assigned during analysis to represent cell types or other groupings.

*seurat[[]]*: This syntax retrieves metadata from the Seurat object.
Metadata typically includes additional information about each spot, such as quality metrics, sample identifiers, or experimental conditions.

*LayerData(seurat, assay="Spatial", layer="counts")*: This command fetches data from a specified layer within a particular assay.
Here, it retrieves raw count data from the "Spatial" assay, which contains the spatial transcriptomics data.

*Embeddings(seurat)*: This function extracts embeddings from dimensionality reduction techniques applied to the Seurat object, such as PCA, UMAP, or t-SNE.
Dimensionality reduction is often used to visualise and analyse high-dimensional data by projecting it into a lower-dimensional space.
Embeddings provide a way to explore the data's structure and relationships.

*Loadings(seurat)*: This command retrieves the loadings from the principal component analysis (PCA) performed on the data.
Loadings indicate how much each feature contributes to the principal components.
PCA is a common dimensionality reduction technique that identifies the directions (principal components) in which the data varies the most.
Loadings help interpret the PCs by showing which genes drive the observed variation.

*FetchData(seurat, vars=c("Epcam", "Cd3d"), assay="Spatial", layer="counts")*: This function fetches expression data for specific genes (here, "Epcam" and "Cd3d") from the specified assay and layer.
It is useful for analysing gene-specific expression patterns.

*Images(seurat)*: This command provides a list of image names associated with the spatial data.
These images typically include tissue histology images or spatial coordinate overlays used in spatial transcriptomics experiments.

*GetTissueCoordinates(seurat)*: This function extracts the spatial coordinates for each spot on the tissue slide, which is essential for mapping gene expression patterns onto the tissue structure.

```{r Exploring Seurat Object}
Cells(seurat) #Cell or spot barcodes
Features(seurat) # All genes or other features measured
Features(seurat[["Spatial"]]) # All features specifically in the spatial assay
Assays(seurat) # Assays
Idents(seurat) # Currently stored active identity - this would normally be a cell type or sample group
seurat[[]] # meta data
LayerData(seurat, assay="Spatial", layer="counts") # data from a specific assay
# Embeddings(seurat) # Any dimensionality reductions # crashes it as it looks for 'pca'
# Loadings(seurat) # PC loadings # crashes it as it looks for 'pca'
FetchData(seurat, vars=c("Epcam", "Cd3d"), assay="Spatial", layer="counts") # Data for specific genes
Images(seurat) # Image names in spatial data
GetTissueCoordinates(seurat) # spot tissue coordinates
```

##READING IN AUTOMATED TISSUE DETECTION INFORMATION

10x Spaceranger software carries out automated tissue detection based on H&E images, which is typically reasonably good.

Here, we also want to import this information - it is stored in 'tissue_positions_list.csv' file.

The provided code reads in this file and adds a metadata variable to a Seurat object, indicating whether each spot is under tissue or outside tissue based on Space Ranger estimates.

```{r Reading In Automated Tissue Detection Information}
coords <- read.csv(file.path(visium_dir, "/spatial/tissue_positions.csv"))

rownames(coords) <- coords$barcode

seurat$UnderTissue <- ifelse(coords[Cells(seurat), "in_tissue"], 
                             yes="Under Tissue", 
                             no="Outside Tisue")
```

##VISUALISING THE SECTION

*SpatialDimPlot* is a Seurat function used to create spatial plots of the spots on a tissue section.
It provides a visual representation of spatial transcriptomics data, showing where each spot is located on the tissue and how it is categorised according to a chosen metadata variable, all plotted over the reference H&E image.
*SpatialDimPlot* is used to plot categorical variables.

*group.by* Argument: specifies the metadata variable used to colour the spots in the plot.
In this case, "UnderTissue" is the variable that delineates whether each spot is under tissue or outside tissue.

Additional useful arguments that can be used to customise the plot:

*cols*: Custom colours for each category.
e.g. *'cols = c("Under Tissue" = "blue", "Outside Tissue" = "grey")'* *pt.size*: Adjust the size of the spots in the plot.
e.g. *pt.size = 2* for larger spots *alpha*: Adjust the transparency of the spots, which can help in visualising dense areas.
e.g. *alpha=0.8* *title*: Add a title to the plot for better presentation.

Explore additional customisation options in the manual pages for the function: *?SpatialDimPlot*

```{r Visualising Automated Tissue Detection Information}
SpatialDimPlot(seurat, 
               group.by="UnderTissue")
```

##QUALITY CONTROL BASICS

*SpatialFeaturePlot* is used to visualise the spatial distribution of a specific numeric feature (gene or metric) across the tissue section in a spatial transcriptomics dataset.
In this example, we're visualising the number of features (genes) detected at each spot on the tissue section.
This metric is automatically calculated at the time of Seurat object creation and is stored in nFeature_Spatial meta data variable.

This metric is commonly used in spatial transcriptomics to assess the complexity and quality of data at each spot.
A high number of features may indicate areas with more complex or diverse cell types, while a low number might indicate poor-quality spots or regions with few active genes.

```{r Visualising Gene Detection Rate}
SpatialFeaturePlot(seurat, "nFeature_Spatial") 
```

Similar to the number of genes detected, we can also plot the number of molecules/UMIs detected per spot.
This is automatically calculated at data loading step and is stored in the *nCount_Spatial* meta data variable.

The two metrics should generally correlate.
High molecule count and low gene count could mean that the spot is homogenous i.e. consists of only few cell types.

Low molecule count and low gene count could mean that thee are data quality issues in those regions.
This could be due to tissue quality, or non-optimal tissue permeabilisation or other technical issues.
But, it could also correspond to low cell density regions - it is important to understand the structural composition of your samples before you throw any data away.
In spatial transcriptomics, there is generally much more variability in QC metrics between different regions than between different cell types in scRNA-Seq data.

```{r Visualising Molecule Detection Rate}
SpatialFeaturePlot(seurat, "nCount_Spatial") 
```

The below code calculates some additional QC metrics- the percentage of ribosomal and mitochondrial gene expression per spot in a Seurat object.
This is a common practice in single-cell RNA-seq data analysis and can also be applied to spatial transcriptomics data, albeit with some considerations about its utility in this context.

*PercentageFeatureSet* is a function in the Seurat package used to calculate the percentage of counts from features (genes) that match a given pattern.
The resulting percentage is stored as metadata in the Seurat object.

*pattern="\^Rp"*: This pattern matches all genes starting with "Rp", which typically represents ribosomal proteins in many organisms.
The caret (\^) signifies that the gene name should start with "Rp".
Ribosomal proteins (genes starting with "Rp") are involved in protein synthesis.
In single-cell analysis, high ribosomal content can sometimes indicate stressed or rapidly proliferating cells, but in spatial transcriptomics, its interpretation might differ due to the complex tissue environment.

*pattern="\^mt-"*: This pattern matches genes starting with "mt-", which typically denotes mitochondrial genes.
The percentage of mitochondrial gene expression is often used as a quality control metric in single-cell RNA-seq.
High mitochondrial content may indicate damaged or dying cells, but its interpretation in spatial data needs careful consideration.
In spatial transcriptomics, this metric can be less straightforward but might still indicate regions of potential artefact or high metabolic activity.

Tissue-specific context should always guide the analysis.

```{r Calculating Addition QC Metrics}
seurat <- PercentageFeatureSet(seurat, 
                               pattern="^Rp", 
                               col.name = "percent.rp")

seurat <- PercentageFeatureSet(seurat, 
                               pattern="^mt-", 
                               col.name =  "percent.mt")
```

Another call to *SpatialFeaturePlot*, this time to visualise the percentage of mitochondrial and ribosomal gene expression.

We can see in the outputs that there is a bias in mitochondrial and ribosomal gene expression in parts of the slide.

The peanut-shaped region in the center of the slide with high ribosomal counts is an immune follicle.
As T-cells generally express highly levels of ribosomal protein genes, it is likely due to this.

We can also see higher percentage of mitochondrial genes in some parts of the slide.
Generally, we would expect epithelial cells to have a higher mitochondrial gene count, but in this case it does not quite correspond to histology across all areas.
The left hand side and right hand side of the slide show shifts in these profiles, potentially indicating some technical artefacts.

```{r Visualising Additional QC Metrics}
SpatialFeaturePlot(seurat, "percent.rp") +
SpatialFeaturePlot(seurat, "percent.mt")
```

*Add_Cell_QC_Metrics* is a function from the *scCustomize* package that automatically calculates and adds various QC metrics to a Seurat object.
It streamlines the QC process by providing a set of commonly used metrics that are crucial for assessing the quality of single-cell data and are largely transferrable to spatial transcriptomics data.
The metrics are added to the Seurat object meta data.

You can customise which metrics to calculate via specific arguements.
For example, here we used *add_cell_cycle= FALSE* to turn off calculating cell cycle scores for each spot.

You can inspect new metrics in the object meta data.

```{r Calculating Commonly Used QC Metrics With scCustomize Wrapper}
seurat <- Add_Cell_QC_Metrics(seurat_object = seurat,
                              species = "mouse", 
                              assay = "Spatial", 
                              overwrite = TRUE,
                              add_cell_cycle = FALSE)

head(seurat)
```

*percent_mito_ribo*: provides a single variable for percentage of counts from either mitochondrial or ribosomal RNAs.

```{r Visualising scCustomize Metrics 1}
SpatialFeaturePlot(seurat, "percent_mito_ribo" )
```

Next, we will inspect spot complexity.
This metric, stored as *log10GenesPerUMI* variable in the meta data, indicates the number of unique genes per molecule and it gives an indication of the diversity of the transcriptome captured in each spot.

A higher value of *log10GenesPerUMI* suggests greater transcriptome complexity and richness, while lower values might indicate technical artefacts or regions with lower biological diversity.

We can visualise this over the tissue slide, but also the distribution as a histogram.
The latter is useful if we want to determine and explore any cut-off values.

```{r Visualising scCustomize Metrics 2}
SpatialFeaturePlot(seurat, "log10GenesPerUMI" ) +
QC_Histogram(seurat, features = "log10GenesPerUMI")
```

The below code visualises an alternative complexity metric, indicating the percentage of total unique molecules occupied by the top 50 most highly expressed genes per spot in a spatial transcriptomics dataset.
This metric can offer insights into the complexity and quality of each spot's transcriptome, particularly highlighting regions with very low diversity.
A high percentage indicates that a small number of genes dominate the transcriptome in that spot, suggesting low complexity.
Conversely, a lower percentage suggests a more diverse and complex transcriptome.

As we would expect, the complexity of (most) spots outside the tissue covered area is very low and under tissue (mostly) high.

We can use the values of QC metrics outside tissue as a guide to identify poor-quality spots under tissue.

**Which under-tissue spots would you remove based on this information?** **Why are there spots outside tissue area with high complexity?**

```{r Visualising scCustomize Metrics 3}
SpatialFeaturePlot(seurat, "percent_top50" ) +
QC_Histogram(seurat, features = "percent_top50")
```

The below code snippet additionally explores the spatial distribution of various pathway scores.
These scores, such as oxidative phosphorylation (oxphos), apoptosis (apop), DNA repair, and immediate-early gene expression (ieg), can serve as quality control metrics but again often highlight real biological phenomena in tissue sections.
Understanding the context and implications of these scores is crucial for accurate interpretation.

High expression of IEGs is sometimes associated with post-mortem artefacts, as cells may exhibit stress responses shortly after death.

Epithelial cells often have higher mitochondrial content, leading to higher oxidative phosphorylation scores.
This can be an indicator of cellular metabolism and energy requirements.

```{r}
SpatialFeaturePlot(seurat, "percent_oxphos" )
SpatialFeaturePlot(seurat, "percent_apop" )
SpatialFeaturePlot(seurat, "percent_dna_repair" )
SpatialFeaturePlot(seurat, "percent_ieg" ) 
```

The code snippet below creates a filter to identify problematic spots based on the number of detected genes and visualises which spots would be kept and which filtered out.
At the current threshold, this would remove a small handful of poor quality spots from under tissue areas.

In this case, we can also see that many spots outside the tissue covered area also pass this QC filter!

**Which additional QC metrics would you use to create a more robust filter?** **Which thresholds would be most appropriate to use?**

```{r}
seurat$SpotFilter <- seurat$nFeature_Spatial > 1500 
SpatialDimPlot(seurat, group.by = "SpotFilter")
```

In the below code snippet, by plotting the distribution of gene and molecule detection rate under and outside tissue covered areas, we can see that there is quite a bit of overlap.

This occurs due to diffusion and can occur to varying degrees in different tissue types but also across different tissue areas.

Optimising tissue permeabilisation times (in older Visium protocols) can improve this.

What this means that there is also diffusion between spots under tissue and we can often detect specific cell type specific gene expression in spots where there should not be any.

```{r}
ggplot(seurat[[]], aes(nFeature_Spatial, colour=UnderTissue)) + geom_density()
ggplot(seurat[[]], aes(nCount_Spatial, colour=UnderTissue)) + geom_density()
```

R package SpotClean (See reference publication: <https://www.nature.com/articles/s41467-022-30587-y>) can help us deal with contamination between spots somewhat.

The below code snippet will incorporate a decontamination step into our workflow.

*read10xVisium* from the *SpatialExperiment* package reads Visium data output from 10X Genomics.
This function loads raw spatial transcriptomics data into a SpatialExperiment object and prepares the raw data for processing with SpotClean, which requires input in the SpatialExperiment format.

*spotclean* function processes the *SpatialExperiment* object to correct for RNA diffusion and background contamination.
This step can take around 15 minutes to run.
To skip it, you can load a pre-computed *SpatialExperiment* object with default parameters.

*assays(se)[["decont"]]*: Extracts the decontaminated counts from the SpotClean-processed data, which are stored in 'decont' assay.

*rownames(clean) \<- rowData(se)\$symbol*: Replaces row names, which are by default ensembl IDs, with gene symbols for readability and compatibility with Seurat object.

*CreateAssayObject* creates a new assay called SPOTCLEAN in the Seurat object using the decontaminated data from SpotClean.
By adding the corrected counts as a new assay, we can preserve both raw and corrected data in the Seurat object and compare the two.

```{r}
se <- read10xVisium(visium_dir, 
      data="raw")
se <- spotclean(se, 
                gene_keep = rownames(se), 
                gene_cutoff = 0)
#se <- readRDS("/project/shared/spatial_data_camp/datasets/PRECOMPUTED/spotclean.RDS")

clean <- assays(se)[["decont"]]
rownames(clean) <- rowData(se)$symbol 

seurat[["SPOTCLEAN"]] <- CreateAssayObject(clean)

```

Next, we visualise decontamination effects on total UMI or gene counts.
Overall, it is not a big effect.

```{r}
p1 <- SpatialFeaturePlot(seurat, features = "nFeature_Spatial")
p2 <- SpatialFeaturePlot(seurat, features = "nFeature_SPOTCLEAN")

p1 + p2
```

To examine the effects on individual genes, we first normalise the data to library size in both the original data and the decontaminated data.

Here, we use a quick log normalisation and library size scaling function in Seurat.

*NormalizeData* normalises the gene expression data within a specified assay of a Seurat object.
By default, it scales counts for each spot by the total expression, multiplies by a scale factor (usually 10,000), and then log-transforms the result.

*assay = "Spatial"*: Specifies the assay to be normalised.
Here, it's the original spatial data before decontamination.

```{r}
seurat <- NormalizeData(seurat, assay = "Spatial")
seurat <- NormalizeData(seurat, assay="SPOTCLEAN")
```

Let's explore how to visualise the effects of SpotClean decontamination on the expression of individual genes, using the highly expressed gene Myh11 as an example.
Myh11 (Myosin heavy chain 11) is typically expressed in the muscularis mucosa layer of the intestine, and we aim to assess how decontamination affects its expression pattern across the tissue.

*DefaultAssay* sets the active assay for a Seurat object.
This determines which data is accessed for functions like plotting and analysis and allows us to switch between corrected and uncorrected gene expression values.

We can see that correcting for diffusion artefacts results in much cleaner signal that reflects tissue histology better.

However, we always need to be careful when applying these types of approaches as potentially we can accidentally also remove some real biological signal.
It is always worth comparing outcomes from corrected and uncorrected analyses.

**Which other genes have been corrected?**

```{r}
gene <- "Myh11"

DefaultAssay(seurat) <- "Spatial"
p1 <- SpatialFeaturePlot(seurat, features = gene)
DefaultAssay(seurat) <- "SPOTCLEAN"
p2 <- SpatialFeaturePlot(seurat, features = gene)

p1 + p2
```

##CLUSTERING ANALYSIS

To ensure that cluster analysis in spatial transcriptomics data is performed on high-quality spots, it's essential to remove spots not under tissue and those that are low quality.

The code snippet below subsets the Seurat object based on specific criteria.

*UnderTissue == "Under Tissue"*: Filters spots to retain only those identified as being under tissue.
This is based on metadata indicating which spots are genuinely covered by tissue, helping to exclude background or artefactual spots.

*SpotFilter*: A logical vector that was previously defined to include only spots with more than 1,500 detected genes.
This ensures that spots with low feature counts, which could be artefacts or of lower quality, are excluded from the analysis.

**Did you include any additional QC metrics in the filter?**

```{r}
seurat <- subset(seurat, UnderTissue == "Under Tissue" & SpotFilter )
```

As the first step for clustering analysis, lets discuss how to normalise spatial transcriptomics data.

*SCTransform* is an advanced normalisation method in Seurat that models gene expression data using regularised negative binomial regression.
It accounts for sequencing depth and other confounding factors, providing a robust framework for normalising single-cell and spatial transcriptomics data.
This tends to perform a bit better than log normalisation approach used above.

*assay = "SPOTCLEAN"*: Specifies the assay to be normalised.
Here, we focus on the SpotClean-corrected data but we could use the uncorrected values instead.

```{r}
seurat <- SCTransform(seurat, assay="SPOTCLEAN", return.only.var.genes = FALSE)
```

We can visualise both raw counts values and normalised values using Myh11 expression as an example:

```{r}
gene <- "Myh11"
p1 <- SpatialFeaturePlot(seurat, gene, slot="data") # Normalised counts
p2 <- SpatialFeaturePlot(seurat, gene, slot="counts") # Raw counts

p1 + p2
```

Reducing dimensionality is a crucial step in the analysis of high-dimensional spatial transcriptomics data.
It simplifies the data structure while retaining its most informative features, which is essential for tasks such as clustering, visualisation, and identifying patterns of gene expression across spots.
Here, we'll go through the process of running Principal Component Analysis (PCA) on a Seurat object.

PCA reduces the dimensionality of the dataset by transforming it into a set of orthogonal axes, known as principal components (PCs), which capture the most variance in the data.
This process helps in identifying and focusing on the most informative features, filtering out noise and redundancy.

*RunPCA* is a function in Seurat that performs PCA on the data stored within a Seurat object, typically after normalisation and identification of variable features.
PCA is often the first step in a series of dimensionality reduction techniques used to prepare the data for clustering and visualisation.

Output: The Seurat object is updated with the computed principal components, which are stored for further analysis and visualisation.
This includes the loading matrix, which shows how each feature contributes to the principal components.
Top positive and negative loading genes for each PC are automatically printed out.

```{r}
seurat <- RunPCA(seurat)
```

After PCA, we need to decide how many PCs to use for clustering and further analyses:

*ElbowPlot* function in Seurat is a valuable tool for determining the number of PCs to include in downstream analyses, such as clustering or UMAP visualisation.
By plotting the percentage of variance explained by each PC, it helps identify the point at which additional PCs contribute minimal additional variance---often referred to as the "elbow" of the plot.

```{r}
ElbowPlot(seurat, 50)
```

Biological Relevance: Also consider biological knowledge and visual inspection of PCA plots to ensure that selected PCs capture relevant patterns.

We can achieve this by visualising gene loadings of each PC to understand what kind of biological variation they capture.

PC 1: Might highlight major tissue regions or dominant cell types - OR, dominant technical effects.
PC 10: Could reflect variation related to specific cellular processes or less prominent tissue structures.
PC 30: Might capture noise or subtle patterns, like rare cell states or technical variations.

**What biological processes are reflected in the top PCs? Can you tell just from the gene loadings?**

```{r fig.height=10, fig.width=7}
PC_Plotting(seurat, dim_number = 1)
PC_Plotting(seurat, dim_number = 10)
PC_Plotting(seurat, dim_number = 30)
```

The below code visualises PCs and histological features using the *SpatialFeaturePlot* function in Seurat.
This approach helps link the dimensionality reduction results back to the tissue's spatial and histological context.

```{r}
SpatialFeaturePlot(seurat, "PC_1", pt.size.factor = 2)
SpatialFeaturePlot(seurat, "PC_10", pt.size.factor = 2)
```

Finding clusters in spatial transcriptomics data is a crucial step for identifying groups of spots with similar expression profiles, which can correspond to different cell types or functional regions within the tissue.

*FindNeighbors*: This step identifies nearest neighbors for each spot based on the selected PCs.
It establishes the underlying graph structure used for clustering.
The choice of PCs affects the quality of clustering.
Too few PCs might miss important variations, while too many might introduce noise.

*FindClusters*: Using the graph created in the previous step, the clustering algorithm partitions the spots into distinct groups.
The resolution parameter determines the granularity of the clustering.

Resolution Parameter *Resolution = 0.5*: This is a common starting point for many analyses, providing a balance between sensitivity and specificity.
However, the optimal resolution varies based on dataset complexity and biological context.

Higher Resolution: Leads to more, smaller clusters.
Useful for detailed analyses where subtle differences are biologically meaningful.

Lower Resolution: Results in fewer, larger clusters.
Suitable when you expect broader, more general differences in the data.

```{r}
seurat <- FindNeighbors(seurat, dims = 1:12)
seurat <- FindClusters(seurat, resolution = .5)
```

Embedding spatial transcriptomics data using Uniform Manifold Approximation and Projection (UMAP) is a powerful way to visualise high-dimensional datasets in a two-dimensional space (or more - we can create 3D visualisations, for example, though that's mostly for fun).

Preserve Structure: UMAP is designed to maintain both local and global data structures, which helps in visualising the relationships between data points accurately.

Cluster Separation: UMAP often provides better separation of clusters than other methods, making it useful for identifying distinct groups within data.

Scalability: UMAP is computationally efficient, allowing it to handle large datasets commonly found in spatial transcriptomics.

*RunUMAP* computes UMAP embeddings for the data stored in the Seurat object, transforming it into a two-dimensional representation that can be easily visualised.

```{r}
seurat <- RunUMAP(seurat,  dims = 1:12)
```

Visualising transcriptome clusters is an essential step in spatial transcriptomics analysis, as it helps identify and interpret the distinct biological structures and cell populations within the tissue.

*DimPlot* generates a plot of spots in a reduced-dimensionality space.
This plot is coloured by cluster identity, allowing to visually assess the grouping and separation of clusters.

```{r}
DimPlot(seurat, label=T, repel=T)
```

And alongside, we can visualise how the clusters correspond to tissue space and align with histology using *SpatialDimPlot* function, as before.

**Do all clusters correspond with histology?** **Do some areas look over or under clustered?** **Do some clusters look like they may correspond to technical artefeacts? Would additional QC help?**

```{r}
SpatialDimPlot(seurat, pt.size.factor = 2)
```

Clusters are stored in the meta data of the seurat object, and automatically set as the current active identity of the object.

```{r}
head(seurat)
```

The choice of cluster resolution in the FindClusters function significantly impacts the granularity of the resulting clusters.
Let's explore the concept of clustering resolution and how to determine the optimal value for the analysis by trying high and low values.

```{r}
seurat <- FindClusters(seurat, resolution = .1)
DimPlot(seurat, label=T, repel=T)
SpatialDimPlot(seurat, pt.size.factor = 2)
```

```{r}
seurat <- FindClusters(seurat, resolution = 1)
DimPlot(seurat, label=T, repel=T)
SpatialDimPlot(seurat, pt.size.factor = 2)
```

The clustree package is for visualising and assessing the stability of clusters obtained from different resolution settings in clustering analyses.
It helps in understanding how clusters change across different resolutions and identifying stable clusters that persist, which can provide insights into the optimal clustering parameters for your spatial transcriptomics data.

*clustree* function visualises the hierarchical relationships between clusters obtained at different resolutions.
It provides a tree-like diagram where nodes represent clusters, and edges show how clusters split or merge as the resolution changes.

Stable Clusters: Look for nodes that maintain a consistent presence across resolutions, indicating stable clusters.

Dynamic Changes: Identify where clusters split or merge, offering insights into biological or technical drivers behind these changes.

```{r fig.height=10, fig.width=7}
clustree(seurat)
clustree(seurat,  node_colour = "sc3_stability")
```

##IDENTIFYING MARKER GENES FOR SPATIAL REGIONS

Identifying marker genes for spatial regions in spatial transcriptomics data is a crucial step in understanding the distinct biological characteristics of each cluster.
The *FindMarkers* function in Seurat is commonly used for this purpose, allowing you to perform differential expression analysis to identify genes that are significantly enriched in specific clusters compared to others.

**Available Tests for Differential Expression** The FindMarkers function supports several statistical tests for identifying marker genes.
The choice of test depends on your data characteristics and analysis goals:

*Wilcoxon Rank Sum Test (test.use = "wilcox")*:

Default: This non-parametric test is the default in Seurat and is suitable for small sample sizes or non-normally distributed data.
Use Case: Quick to run and useful when no confounding variables need to be adjusted.

*Likelihood-Ratio Test for Single Cell Gene Expression (test.use = "bimod")*:

Bimodality: Assumes gene expression is bimodally distributed.
Use Case: Good for single-cell RNA-seq data with dropout events.

*Student's t-test (test.use = "t")*:

Parametric: Assumes data is normally distributed.
Use Case: Suitable for large datasets where normality can be assumed.

*Logistic Regression (test.use = "LR")*:

Regression: Uses logistic regression to assess differential expression.
Use Case: Useful for handling confounding variables.

*Negative Binomial Generalized Linear Model (test.use = "negbinom")*:

Counts: Suitable for count data with overdispersion.
Use Case: Useful for spatial or single-cell data with count overdispersion and can handle confounding variables.

*Poisson Generalized Linear Model (test.use = "poisson")*:

Poisson: Assumes data follows a Poisson distribution.
Use Case: Best for count data without overdispersion.

*MAST (test.use = "MAST")*:

Zero-inflation: Handles zero-inflated data effectively.
Use Case: Particularly useful for single-cell RNA-seq data.

*DESeq2 (test.use = "DESeq2")*:

Normalization: Adjusts for library size and compositional bias.
Use Case: Effective for bulk RNA-seq and spatial transcriptomics.

**Parameter settings**

*logfc.threshold*: Sets a threshold for the minimum log fold change required to be considered significant.
Helps filter out genes with minor expression differences.

*min.pct*: Specifies the minimum percentage of cells expressing the gene to be included in the analysis.
Helps focus on biologically relevant genes.

*min.diff.pct*: Minimum difference in the percentage of cells expressing the gene between the two groups.
Useful for highlighting stark differences.

The above parameters for spatial data generally should be lowered from defaults, which are tuned for single cell datasets.
In ST data, these thresholds sometimes filter out a lot of meaningful gene expression that can be more sparse than in single cell data.

*latent.vars*: Adjusts for latent variables or confounders in the data, such as batch effects or technical artefacts.

```{r}
markers.cl1 <- FindMarkers(seurat, ident.1="1")
```

Inspect the top results:

```{r}
head(markers.cl1)
```

Seurat offers a variety of visualisation tools for exploring gene expression patterns and spatial distributions in spatial transcriptomics data.
These tools provide views into how specific genes are expressed across clusters, conditions, or spatial regions.

*VlnPlot* creates a violin plot to show the distribution of gene expression levels across clusters or other groupings.
*group.by* Argument: Specifies which metadata grouping to use for the x-axis, such as clusters or tissue types.

*FeaturePlot* plots the expression of a gene on a reduced-dimensionality plot, such as UMAP or PCA, highlighting where the gene is expressed in the cluster space.

*SpatialFeaturePlot* visualises the spatial distribution of gene expression on a tissue section, highlighting the areas where a specific gene is expressed.

```{r}
SpatialFeaturePlot(seurat, "Nr4a1")
```

```{r}
VlnPlot(seurat, "Nr4a1")
```

```{r}
FeaturePlot(seurat, "Nr4a1")
```

Using the FindAllMarkers function in Seurat is a convenient way to identify marker genes for all clusters in a single step.
This function performs differential expression analysis for each cluster, comparing it to all other clusters, and compiles a list of significant markers for each cluster.
The same arguements - e.g. different statistical tests - apply here.

```{r}
markers <- FindAllMarkers(seurat)
```

```{r}
head(markers)
```

scCustomize package provides a convenient helper function, *Extract_Top_Markers*, to extract the top marker genes for each cluster from the output of *FindAllMarkers*.
This function simplifies the process of identifying and retrieving the most significant marker genes for analysis and visualisation.

In this case, we are extracting the top five markers per cluster.

```{r}
top <- Extract_Top_Markers(markers, num_genes = 5, named_vector = FALSE, make_unique = TRUE)
top
```

*Clustered_DotPlot* function from the *scCustomize* package provides a convenient and visually appealing way to display expression patterns of top marker genes across clusters using a dot plot.
This function not only plots the expression data but also clusters the genes and groups for enhanced visual interpretation.
This is an alternative to Seurat *DotPlot* function.

*k = 8*: Determines the number of clusters for the hierarchical clustering of genes to enhance visual separation of expression patterns.

```{r fig.height=10, fig.width=7}
Clustered_DotPlot(seurat, features = top, k=8)
```

##SPATIALLY VARIABLE FEATURES

Finding spatially variable features in spatial transcriptomics data is an essential step for identifying genes with expression patterns that vary across spatial regions of the tissue.

Identify Spatial Patterns: Detect genes that show spatially distinct expression patterns, revealing potential tissue structures or specialised regions.

Biological Understanding: Spatially variable features can highlight key functional areas within the tissue, and highlight spatial heterogeneity.

Further Analysis: We can use spatially variable features to improve clustering - this tends to yield results that correlate with histology better than variably expressed genes.

The *FindSpatiallyVariableFeatures* function in Seurat allows you to detect such features using various methods, one of which is Moran's I, a measure of spatial autocorrelation.

Moran's I is a measure of spatial autocorrelation, which quantifies the degree to which similar values occur near each other in a spatial dataset.
It is widely used in spatial analysis to determine if there is a pattern in the spatial distribution of a particular variable, such as gene expression levels in spatial transcriptomics data.
Moran's I helps identify spatially variable features that may be linked to biological structures or processes.

Interpretation of Moran's I Range: Moran's I ranges from -1 to +1.

Positive Values: Indicate positive spatial autocorrelation, meaning similar values cluster together in space.
For example, regions with high expression levels are near other regions with high expression levels.

Negative Values: Indicate negative spatial autocorrelation, meaning dissimilar values are adjacent.
This might suggest alternating patterns or competitive interactions.

Zero: Indicates no spatial autocorrelation, meaning the spatial distribution is random.

Significance: The significance of Moran's I is often tested using a permutation test, which evaluates whether the observed value of Moran's I could occur by chance under a null hypothesis of spatial randomness.

Seurat also wraps an alternative method *'markvariogram'*.

A variogram is a function that describes how data variance changes with spatial distance.
It is commonly used in geostatistics to model spatial dependencies and can reveal the scale and intensity of spatial patterns.
In the context of spatial transcriptomics, a variogram quantifies how gene expression variance changes as a function of distance between tissue spots or cells.

Mark variograms are a special type of variogram used for point processes where each point (or spatial unit) has an associated mark (e.g., gene expression level).
The method analyses the spatial dependence of these marks to identify genes with significant spatial variability.

Moran's I vs. Markvariogram: While Moran's I captures overall spatial autocorrelation, markvariograms focus on variance over distance, which can capture more detailed spatial structures.

```{r}
seurat <- FindSpatiallyVariableFeatures(seurat, assay = "SCT", selection.method = "moransi") # ~ 20 mins running time
#pre-computed table is available as an RDS file here: /project/shared/spatial_data_camp/datasets/PRECOMPUTED/sp.var.genes.RDS
```

*SpatiallyVariableFeatures* function in Seurat is typically used to extract spatially variable features identified by methods like Moran's I or mark variogram.
If this function is not working due to a bug or issue (like it is in the current version of Seurat we are using), you can directly access the information stored in the meta.features slot of the assay.

```{r, eval=FALSE}
SpatiallyVariableFeatures(seurat, assay = "SCT", selection.method = "moransi" )
```

Columns in the output:

*moransi.spatially.variable.rank*: Indicates the rank of the gene's spatial variability.
Lower values suggest higher spatial variability.

*moransi.spatially.variable.p.value*: Provides the p-value associated with the spatial variability test, indicating statistical significance.

*moransi.spatially.variable*: A logical indicator of whether the gene is considered spatially variable based on a specified threshold.

```{r}
sp.var.genes <- seurat@assays[["SCT"]]@meta.features
sp.var.genes <- sp.var.genes[order(sp.var.genes$moransi.spatially.variable.rank), ]
head(sp.var.genes)
```

**What do the most spatially variable genes look like?** **What about the least variable?**

```{r}
SpatialFeaturePlot(seurat, "mt-Co3")
SpatialFeaturePlot(seurat, "Hmgcs2")
```

Clustering spatial transcriptomics data using spatially variable genes is often a better approach that often aligns more closely with histological features than traditional clustering methods based on variable genes.
By focusing on genes that exhibit significant spatial variability, this approach highlights biologically meaningful patterns and structures in tissue architecture.
By focusing on genes with spatial patterns, this approach minimises the impact of uniformly expressed or randomly varying genes, which can introduce noise into clustering solutions.

Lets repeat the clustering analysis, but using spatially variable features only.

```{r}
seurat <- SCTransform(seurat, assay="Spatial", residual.features=rownames(sp.var.genes)[1:2000])
seurat <- RunPCA(seurat)
seurat <- RunUMAP(seurat, dims=1:12)
seurat <- FindNeighbors(seurat, dims = 1:12)
seurat <- FindClusters(seurat, resolution = .5)
```

Visualise the updated clustering solution.

**How much does this approach change the previous clustering solution?**

```{r}
DimPlot(seurat, label=T, repel=T)
SpatialDimPlot(seurat, pt.size.factor=2)
```

##CELL TYPE DECONVOLUTION

Many ST platforms capture gene expression data at resolutions that encompass multiple cells within each spatial spot.
In this case, each Visium spot is approximately 55 micrometres in diameter and can cover multiple cell types, particularly in dense or heterogeneous tissues.
This mixing of cell types within a single spot poses a significant challenge for understanding the cellular composition and the spatial organisation of individual cell types.

Cell type deconvolution is the process of estimating the proportions and types of different cells present within a mixed cell population, based on gene expression data.
In the context of spatial transcriptomics, deconvolution methods aim to unravel the cellular composition of each spot by inferring which cell types are present and in what proportions.
This process is crucial for interpreting the spatial organisation of cell types within tissues.

Approaches to Cell Type Deconvolution Several computational approaches have been developed to perform cell type deconvolution in spatial transcriptomics data.
These methods generally fall into two categories:

Reference-Based Methods: These methods use reference expression profiles from single-cell RNA-seq datasets to infer the cell type composition of spatial spots.
They typically involve algorithms that match the expression profiles of spots to those of known cell types.

De Novo Methods: These methods do not rely on external reference datasets and instead use statistical models to infer transcriptional groups from the data directly.

Considerations and Challenges:

Resolution and Spot Size: The resolution of the spatial platform affects the accuracy of deconvolution.
Smaller spot sizes generally yield more precise cell type compositions but may also capture fewer transcripts, leading to increased noise.

Reference Data Quality: The choice and quality of the reference single-cell dataset significantly influence deconvolution accuracy.
The reference must be well-annotated and relevant to the tissue being studied.
The majority of available methods are reference-based and these tend to perform better than reference-free approaches, but this entirely hinges on using an appropriate reference.

Reference Data Resolution: Many deconvolution algorithms struggle to accurately distinguish closely related cell types.
e.g.
T-Cell vs B-Cell is straightforward, but CD4+ T-Cell vs CD8+ T-Cell (or even finer subsets than that) predictions should be interpreted more cautiously.

Here, we will use a reference-based method CARD.
It is currently one of the best performing methods implemented in R, although many others are available.

For additional documentation, see here: <https://yma-lab.github.io/CARD/>

As a reference, we will use a mouse intestine scRNA-Seq dataset.
We can read in this data from a previously prepared Seurat object.

```{r}
ref <- readRDS("/project/shared/spatial_data_camp/datasets/SINGLE_CELL_REFERENCES/mouse_hc_colon_ref.RDS")
```

Let's visualise the dataset - here, we can see that the dataset has all major epithelial, mesenchymal and immune cells present in the tissue.

**What would happen if your reference was incomplete/missing key cell types?** **Try removing cell populations from the reference to see how incomplete references impact deconvolution**

```{r}
DimPlot(ref, label=T, repel=T)
```

*createCARDObject* function is used to initialise the CARD analysis pipeline.
The function takes as input both single-cell RNA-seq data and spatial transcriptomics data, and it outputs an object that can be used for further deconvolution analysis.

*sc_count* : This argument specifies the single-cell RNA-seq count matrix.
It contains the gene expression data from the single-cell reference dataset.
*LayerData(ref, assay = "RNA", layer = "counts")* retrieves the counts layer from the single-cell reference data stored in the ref Seurat object.

*sc_meta* : This argument provides the metadata associated with the single-cell RNA-seq dataset.
It typically includes annotations such as cell type labels and sample information.
*ref[[]]* accesses the metadata for the ref Seurat object, which includes cell type annotations needed for deconvolution.

*spatial_count* : This argument specifies the spatial transcriptomics count matrix, which contains the gene expression data for each spatial spot.
*LayerData(seurat, assay = "SCT", layer = "counts")* retrieves the counts layer from the seurat object that contains spatial data.

*spatial_location* : This argument provides the spatial coordinates of each spot in the spatial transcriptomics dataset.
*GetTissueCoordinates(seurat)* extracts the spatial coordinates of spots from the seurat object.

*ct.varname* : Specifies the column name in the scRNA-seq metadata that contains the cell type annotations.

*ct.select* : This argument selects which cell types to include in the deconvolution process.
*unique(ref\$CellType)* extracts all cell types names from the single-cell dataset.

*sample.varname* : Specifies the column name in the scRNA-seq metadata that contains the sample identifiers, if the reference data is made up from multiple samples/batches.

```{r}
card <-  createCARDObject(
	sc_count = LayerData(ref, assay = "RNA", layer = "counts"),
	sc_meta = ref[[]],
	spatial_count = LayerData(seurat, assay = "SCT", layer = "counts"),
	spatial_location = GetTissueCoordinates(seurat),
	ct.varname = "CellType",
	ct.select = unique(ref$CellType),
	sample.varname = "Sample",
	minCountGene = 100,
	minCountSpot = 5) 
```

The CARD deconvolution process aims to disentangle the mixed gene expression signals from spatial transcriptomics data by inferring the proportions of different cell types present in each spatial spot and is wrapped in *CARD_deconvolution* function.

Outputs: The card object is updated with deconvolution results, including estimated cell type proportions for each spatial spot.
This is a matrix where each row represents a spatial spot and each column represents a cell type, with values indicating the estimated proportion of each cell type in each spot.

```{r}
card <- CARD_deconvolution(CARD_object = card)
```

We can visualise the results using *CARD.visualize.pie* function.
It creates pie charts for each spatial spot, representing the estimated proportions of different cell types within each spot.
We can tweak the colours and other visual parameters.

\*[card\@Proportion](mailto:card@Proportion){.email}\_CARD\* accesses the proportion matrix from the CARD object.
Each row represents a spatial spot, and each column represents a cell type, with values indicating the estimated proportions.

\*[card\@spatial](mailto:card@spatial){.email}\_location\* accesses the spatial location data stored in the CARD object.
It provides the x y coordinates of each spot.

```{r fig.height=10, fig.width=10}
CARD.visualize.pie(
	proportion = card@Proportion_CARD,
	spatial_location = card@spatial_location)
```

Adding the predictions from the CARD deconvolution back into the Seurat object is a practical step to centralize your data and useful for further analysis.
By storing the deconvolution results as a separate assay within the Seurat object, you can easily integrate cell type composition data with other analyses, such as visualisation, differential expression, and spatial plotting implemented in Seurat.

```{r}
seurat[["predictions"]] <- CreateAssayObject(t(card@Proportion_CARD))
```

We can then plot the deconvolution results for individual cell types using the same Seurat functions as before.

```{r}
SpatialFeaturePlot(seurat, "Enterocytes", pt.size.factor = 2)
SpatialFeaturePlot(seurat, "B-Cells", pt.size.factor = 2)
SpatialFeaturePlot(seurat, "T-Cells", pt.size.factor = 2)
SpatialFeaturePlot(seurat, "Myofibroblasts", pt.size.factor = 2)
```

```{r}
FeaturePlot(seurat, "Enterocytes")
FeaturePlot(seurat, "B-Cells")
FeaturePlot(seurat, "T-Cells")
FeaturePlot(seurat, "Myofibroblasts")
```

We can use all other standard seurat visualisation functions with cell type probabilities - e.g. heatmap to visualise the distribution of cell types over spatial clusters or other groups.

**How would you identify which cell types are enriched in which clusters/regions?** **What other Seurat functions/analyses could applied to cell type deconvolution results?**

```{r}
DefaultAssay(seurat) <- "predictions"
seurat <- ScaleData(seurat)
DoHeatmap(seurat, features=rownames(seurat))
```

Plotting the correlation of cell type predictions across spatial spots can provide insights into which cell types tend to co-localise and which do not.
This approach involves calculating the correlation matrix for the cell type proportions and visualising it using a correlation plot.
Such an analysis can highlight potential interactions or spatial organisation patterns among different cell types within the tissue.

A simple correlation based approach is quick to calculate, but only considers whether cell signatures are correlating within the same spots.
In this case, because each spot represents multiple co-localising cells, the result is sensible.
For higher resolution data or to consider longer range interactions, a different approach would be needed.
We will explore this in more detail later in the workshop.

```{r}
correlation <- cor(as.matrix(t(GetAssayData(seurat, assay="predictions"))))
corrplot(correlation)
```

Correlation analyses allow us to look at the signatures in the same spots, but what if we want to ask questions about tissue areas that are adjacent to each other?

Constructing a k-nearest neighbours graph based on spatial coordinates can be valuable for analysing spatial relationships.
This allows you to explore various spatially related questions, such as identifying spatial domains, detecting spatial dependencies, and integrating spatial information into clustering or other analyses.

```{r}
coords <- GetTissueCoordinates(seurat, which = "centroids")
neighbours <- FindNeighbors(as.matrix(coords[, c("x", "y")]), k.param = 20, return.neighbor=TRUE)

```

For example, if we can use it automatically select spots that are adjacent or physically close to some feature of interest.
In this case, we want to automatically select any spots that are nearby the group of spots which have been designated as cluster 8, which are the crypt top regions in the middle of the tissue swiss roll.

Because of the rolled up nature of the tissue, it would be very hard to pick out this layer of spots "manually".

This can be useful to explore how cells in adjacent spots might influence or interact with each other.

In other use cases, you may want to select the tumour borders for example.

*WhichCells* identifies the cells (or spots) that belong to a specific cluster or meet a particular expression criterion

*TopNeighbors* finds the top n nearest neighbours for a given set of cells based on the k-NN graph.
Increasing the n here will return more and more distal spots - tweak to your requirements!

```{r}
cells <- WhichCells(seurat, expression= seurat_clusters == 8)
adjacent <- TopNeighbors(neighbours, cells, n = 6)

Idents(seurat) <- "Other Spots"
seurat <- SetIdent(seurat, cells = adjacent, "Adjacent Spots")
seurat <- SetIdent(seurat, cells = cells, "Spots of Interest")

SpatialDimPlot(seurat, pt.size.factor = 2)
```

We can then use these groups to find specific gene expression patterns - e.g. finding the differences between the two adjacent layers.

```{r}
DefaultAssay(seurat) <- "SCT"
diffs <- FindMarkers(seurat, "Adjacent Spots", "Spots of Interest")
head(diffs, 10)
```

```{r}
VlnPlot(seurat, "Saa1")
```

But we can also compare cell type deconvolution results in different layers.
For example, we can see that the top layer of spots does not have a high Goblet cell signature, but the layer of spots we selected underneath does:

```{r}
VlnPlot(seurat, "Goblets")
```

You can save your seurat objects with all analyses as an RDS file to conveniently load it back up when needed or share with collaborators:

```{r}
saveRDS(seurat, file="mouse_intestine_visium.RDS")
```
